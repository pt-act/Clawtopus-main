/**
 * Memory Bank Auto-Updater
 *
 * Automatically maintains memory_bank/ files in end-user projects.
 * This is for IN-PROJECT memory (projects being developed WITH Clawtopus),
 * NOT for Clawtopus's own system memory.
 *
 * Usage: Register this as an internal hook for session lifecycle events.
 */

import fs from "node:fs/promises";
import path from "node:path";
import { ensureDir } from "./internal.js";

export type MemoryBankUpdateContext = {
  workspaceDir: string;
  sessionSummary?: string;
  decisions?: string[];
  skills?: string[];
  learnings?: string[];
};

/**
 * Initialize memory_bank/ structure in a user project if it doesn't exist
 */
export async function initializeMemoryBank(workspaceDir: string): Promise<boolean> {
  const memoryBankDir = path.join(workspaceDir, "memory_bank");

  try {
    const stat = await fs.stat(memoryBankDir);
    if (stat.isDirectory()) {
      return false; // Already exists
    }
  } catch {
    // Doesn't exist, create it
  }

  ensureDir(memoryBankDir);

  // Create initial PROJECT_CONTEXT.md
  const projectContextPath = path.join(memoryBankDir, "PROJECT_CONTEXT.md");
  try {
    await fs.access(projectContextPath);
  } catch {
    await fs.writeFile(
      projectContextPath,
      `# Project Context

## Overview

[Describe what this project is about]

## Purpose

[What problem does this solve?]

## Tech Stack

- Language: 
- Framework: 
- Key Libraries: 

## Recent Updates

<!-- Latest updates prepended here (newest first) -->

---
*Auto-generated by Clawtopus*
`,
      "utf-8",
    );
  }

  return true; // Created new memory_bank/
}

/**
 * Update PROJECT_STATE.md with session summary
 * Prepends entries (newest first)
 */
export async function updateProjectState(workspaceDir: string, summary: string): Promise<void> {
  const memoryBankDir = path.join(workspaceDir, "memory_bank");
  const statePath = path.join(memoryBankDir, "PROJECT_STATE.md");

  const timestamp = new Date().toISOString().split("T")[0];
  const entry = `\n## ${timestamp}\n\n${summary}\n`;

  try {
    const existing = await fs.readFile(statePath, "utf-8");
    // Prepend new entry after the header
    const lines = existing.split("\n");
    const headerEnd = lines.findIndex((line) => line.startsWith("## "));
    if (headerEnd !== -1) {
      lines.splice(headerEnd, 0, entry);
      await fs.writeFile(statePath, lines.join("\n"), "utf-8");
    } else {
      await fs.writeFile(statePath, existing + entry, "utf-8");
    }
  } catch {
    // File doesn't exist, create it
    await fs.writeFile(
      statePath,
      `# Project State

Current state and recent session history (newest first).

${entry}`,
      "utf-8",
    );
  }
}

/**
 * Update DECISIONS.md with architectural decisions
 * Prepends entries (newest first)
 */
export async function updateDecisions(workspaceDir: string, decisions: string[]): Promise<void> {
  if (decisions.length === 0) {
    return;
  }

  const memoryBankDir = path.join(workspaceDir, "memory_bank");
  const decisionsPath = path.join(memoryBankDir, "DECISIONS.md");

  const timestamp = new Date().toISOString().split("T")[0];
  const entries = decisions.map((d) => `- ${d}`).join("\n");
  const block = `\n## ${timestamp}\n\n${entries}\n`;

  try {
    const existing = await fs.readFile(decisionsPath, "utf-8");
    const lines = existing.split("\n");
    const headerEnd = lines.findIndex((line) => line.startsWith("## "));
    if (headerEnd !== -1) {
      lines.splice(headerEnd, 0, block);
      await fs.writeFile(decisionsPath, lines.join("\n"), "utf-8");
    } else {
      await fs.writeFile(decisionsPath, existing + block, "utf-8");
    }
  } catch {
    await fs.writeFile(
      decisionsPath,
      `# Architectural Decisions

Key decisions made during development (newest first).

${block}`,
      "utf-8",
    );
  }
}

/**
 * Update SKILLS.md with reusable patterns
 * Prepends entries (newest first)
 */
export async function updateSkills(workspaceDir: string, skills: string[]): Promise<void> {
  if (skills.length === 0) {
    return;
  }

  const memoryBankDir = path.join(workspaceDir, "memory_bank");
  const skillsPath = path.join(memoryBankDir, "SKILLS.md");

  const timestamp = new Date().toISOString().split("T")[0];
  const entries = skills.map((s) => `- ${s}`).join("\n");
  const block = `\n## ${timestamp}\n\n${entries}\n`;

  try {
    const existing = await fs.readFile(skillsPath, "utf-8");
    const lines = existing.split("\n");
    const headerEnd = lines.findIndex((line) => line.startsWith("## "));
    if (headerEnd !== -1) {
      lines.splice(headerEnd, 0, block);
      await fs.writeFile(skillsPath, lines.join("\n"), "utf-8");
    } else {
      await fs.writeFile(skillsPath, existing + block, "utf-8");
    }
  } catch {
    await fs.writeFile(
      skillsPath,
      `# Project Skills

Reusable patterns and conventions (newest first).

${block}`,
      "utf-8",
    );
  }
}

/**
 * Update CURRICULUM.md with learning moments
 * Prepends entries (newest first)
 */
export async function updateCurriculum(workspaceDir: string, learnings: string[]): Promise<void> {
  if (learnings.length === 0) {
    return;
  }

  const memoryBankDir = path.join(workspaceDir, "memory_bank");
  const curriculumPath = path.join(memoryBankDir, "CURRICULUM.md");

  const timestamp = new Date().toISOString().split("T")[0];
  const entries = learnings.map((l) => `- ${l}`).join("\n");
  const block = `\n## ${timestamp}\n\n${entries}\n`;

  try {
    const existing = await fs.readFile(curriculumPath, "utf-8");
    const lines = existing.split("\n");
    const headerEnd = lines.findIndex((line) => line.startsWith("## "));
    if (headerEnd !== -1) {
      lines.splice(headerEnd, 0, block);
      await fs.writeFile(curriculumPath, lines.join("\n"), "utf-8");
    } else {
      await fs.writeFile(curriculumPath, existing + block, "utf-8");
    }
  } catch {
    await fs.writeFile(
      curriculumPath,
      `# Learning Curriculum

Concepts mastered and knowledge growth (newest first).

${block}`,
      "utf-8",
    );
  }
}

/**
 * Full memory_bank update from session context
 */
export async function updateMemoryBank(context: MemoryBankUpdateContext): Promise<void> {
  const { workspaceDir, sessionSummary, decisions, skills, learnings } = context;

  // Ensure memory_bank/ exists
  await initializeMemoryBank(workspaceDir);

  // Update files that have content
  if (sessionSummary) {
    await updateProjectState(workspaceDir, sessionSummary);
  }

  if (decisions && decisions.length > 0) {
    await updateDecisions(workspaceDir, decisions);
  }

  if (skills && skills.length > 0) {
    await updateSkills(workspaceDir, skills);
  }

  if (learnings && learnings.length > 0) {
    await updateCurriculum(workspaceDir, learnings);
  }
}
